{"version":3,"file":"form-components.js","sources":["../resources/js/components/custom-select.js","../resources/js/util/findLastIndex.js","../resources/js/util/inspect.js","../resources/js/util/regex.js","../resources/js/util/identity.js","../resources/js/util/get.js","../resources/js/util/options.js","../resources/js/components/index.js"],"sourcesContent":["/*\n * Custom Select Component Definition.\n *\n * Note: Not using polyfills for functions such as Array.from()\n * since I use Livewire, and Livewire already includes polyfills\n * for those functions. If you don't use Livewire, you should\n * make sure are pulling in those polyfills.\n */\n\nimport findLastIndex from '../util/findLastIndex';\nimport { normalizeOptions } from '../util/options';\nimport { isArray } from '../util/inspect';\n\nlet createPopper;\n\nexport default (config) => ({\n    focusedOptionIndex: null,\n    filterable: false,\n    data: [],\n    disabled: false,\n    options: [],\n    open: false,\n    search: '',\n    wireFilter: false,\n    wireListeners: [],\n    value: '',\n    selectedOption: null, // for storing a selected option in case a \"wire:filter\" removes the option from the list...\n    max: false,\n    selectId: '',\n    valueField: 'value',\n    textField: 'text',\n    disabledField: 'disabled',\n    labelField: 'label', // used for an \"optgroup\"'s label\n    optionsField: 'options', // used when creating \"optgroups\"\n    popper: null,\n    ...config,\n\n    get buttonDisplay() {\n        if (this.multiple) {\n            let optionDisplay = this.optionDisplay(this.value[0]);\n\n            if (this.value.length > 1) {\n                optionDisplay += ` <span class=\"custom-select__select-count\">+ ${this.value.length - 1}</span>`;\n            }\n\n            return optionDisplay;\n        }\n\n        return this.optionDisplay(this.value);\n    },\n\n    get fieldNames() {\n        return {\n            valueField: this.valueField,\n            textField: this.textField,\n            disabledField: this.disabledField,\n            labelField: this.labelField,\n            optionsField: this.optionsField,\n        };\n    },\n\n    close() {\n        this.open = false;\n        this.focusedOptionIndex = null;\n        this.search = '';\n\n        if (this.popper) {\n            this.popper.destroy();\n            this.popper = null;\n        }\n    },\n\n    clear() {\n        this.value = this.multiple ? [] : null;\n\n        if (this.open) {\n            this.close();\n            this.focusButton();\n        }\n    },\n\n    focusButton() {\n        this.$nextTick(() => this.$refs.button.focus());\n    },\n\n    focusNextOption() {\n        if (this.focusedOptionIndex === null) {\n            this.focusedOptionIndex = -1;\n        }\n\n        let nextIndex = this.options.findIndex((o, index) => index > this.focusedOptionIndex && ! o.disabled && ! this.isOptgroup(o));\n        if (nextIndex === -1 || (nextIndex + 1) > this.options.length) {\n            nextIndex = this.options.findIndex(o => ! o.disabled && ! this.isOptgroup(o));\n        }\n\n        this.focusedOptionIndex = nextIndex;\n\n        this.scrollToOption(this.focusedOptionIndex);\n    },\n\n    focusPreviousOption() {\n        if (this.focusedOptionIndex === null) {\n            this.focusedOptionIndex = this.options.length - 1;\n        }\n\n        let previousIndex = findLastIndex(this.options, (o, index) => index < this.focusedOptionIndex && ! o.disabled && ! this.isOptgroup(o));\n        if (previousIndex < 0) {\n            previousIndex = findLastIndex(this.options, o => ! o.disabled && ! this.isOptgroup(o));\n        }\n\n        this.focusedOptionIndex = previousIndex;\n\n        this.scrollToOption(this.focusedOptionIndex);\n    },\n\n    onHome() {\n        if (! this.open) {\n            return;\n        }\n\n        const firstIndex = this.options.findIndex(o => ! o.disabled && ! this.isOptgroup(o));\n\n        if (firstIndex > -1) {\n            this.focusedOptionIndex = firstIndex;\n\n            this.scrollToOption(this.focusedOptionIndex);\n        }\n    },\n\n    onEnd() {\n        if (! this.open) {\n            return;\n        }\n\n        const lastIndex = findLastIndex(this.options, o => ! o.disabled && ! this.isOptgroup(o));\n\n        if (lastIndex > -1) {\n            this.focusedOptionIndex = lastIndex;\n\n            this.scrollToOption(this.focusedOptionIndex);\n        }\n    },\n\n    isOptgroup(option) {\n        return (option || {}).hasOwnProperty('label');\n    },\n\n    isSelected(value) {\n        if (this.multiple) {\n            return this.value.includes(value);\n        }\n\n        return this.value === value;\n    },\n\n    /*\n     * Calling initialize now so Alpine doesn't call the function twice.\n     */\n    initialize($wire = null, $dispatch = null) {\n        createPopper = window.Popper ? window.Popper.createPopper : window.createPopper;\n\n        if (typeof createPopper !== 'function') {\n            throw new TypeError(`<x-custom-select> requires Popper (https://popper.js.org)`);\n        }\n\n        this.data = [...normalizeOptions(this.data, this.fieldNames)];\n        this.options = this.data;\n\n        if (this.multiple) {\n            this.selectedOption = [];\n        }\n\n        if (this.multiple && ! isArray(this.value)) {\n            this.value = [];\n        }\n\n        if (this.multiple && this.value.length > 0) {\n            this.selectedOption = this.options.find(o => ! this.isOptgroup(o) && o.value === this.value[0]);\n        } else if (! this.multiple && this.value) {\n            this.selectedOption = this.options.find(o => ! this.isOptgroup(o) && o.value === this.value);\n        }\n\n        this.$watch('value', value => {\n            $dispatch && $dispatch('custom-select-value-changed', { id: this.selectId, value });\n        });\n\n        // Allow local filtering if user has not specified wire:filter on the custom select component.\n        this.$watch('search', value => {\n            if (! this.open) {\n                return this.options = this.data;\n            }\n\n            // If the user specifies a \"wire:filter\" method, attempt to call that method,\n            // otherwise just perform local search.\n            if (this.wireFilter && $wire) {\n                $wire[this.wireFilter](value)\n                    .then(data => {\n                        this.data = normalizeOptions(data, this.fieldNames);\n                        this.options = this.data;\n                    });\n\n                return;\n            }\n\n            if (! value) {\n                return this.options = this.data;\n            }\n\n            const lowerCasedSearch = value.toLowerCase();\n\n            this.options = this.data\n                .filter(o => ! this.isOptgroup(o) && (String(o.value).toLowerCase().includes(lowerCasedSearch) || o.text.toLowerCase().includes(lowerCasedSearch)));\n        });\n\n        if ($wire) {\n            // Wire listeners are useful for selects whose options depend on other selects. On the livewire component,\n            // user can emit an event with the options that should be shown in the dependant select based on some\n            // criteria.\n            this.wireListeners.forEach(listener => {\n                $wire.on(listener, data => {\n                    this.data = normalizeOptions(data, this.fieldNames);\n                    this.options = this.data;\n                });\n            });\n        }\n\n        // Emit our value changed event right away for any listeners...\n        $dispatch && $dispatch('custom-select-value-changed', { id: this.selectId, value: this.value });\n    },\n\n    onMouseover(option, index) {\n        if (this.isOptgroup(option) || option.disabled) {\n            return;\n        }\n\n        this.focusedOptionIndex = index;\n    },\n\n    optionClasses(option, index) {\n        const classes = [];\n\n        if (this.isOptgroup(option)) {\n            classes.push('custom-select__opt-group');\n        } else if (index === this.focusedOptionIndex) {\n            classes.push('custom-select__option--hovered');\n        }\n\n        if (this.isSelected((option || {}).value)) {\n            classes.push('custom-select__option--selected');\n        }\n\n        if (option.disabled) {\n            classes.push('custom-select__option--disabled');\n        }\n\n        return classes.join(' ');\n    },\n\n    openMenu() {\n        if (this.disabled) {\n            return;\n        }\n\n        const firstValue = this.multiple ? this.value[0] : this.value;\n        this.focusedOptionIndex = this.options.findIndex(o => o.value === firstValue && ! this.isOptgroup(o));\n        if (this.focusedOptionIndex < 0) {\n            this.focusedOptionIndex = this.options.findIndex(o => ! o.disabled && ! this.isOptgroup(o));\n        }\n\n        this.popper = createPopper(this.$refs.button, this.$refs.container, {\n            placement: 'bottom-start',\n            modifiers: [\n                {\n                    name: 'offset',\n                    options: {\n                        offset: [0, 4],\n                    },\n                },\n                {\n                    name: 'preventOverflow',\n                    options: {\n                        boundary: 'clippingParents',\n                    },\n                },\n                {\n                    name: 'flip',\n                    options: {\n                        padding: 30,\n                    },\n                },\n            ],\n        });\n\n        this.open = true;\n\n        this.$nextTick(() => {\n            if (this.filterable) {\n                this.$refs.search.focus({\n                    preventScroll: true,\n                });\n            }\n\n            this.scrollToOption(this.focusedOptionIndex);\n        });\n    },\n\n    optionDisplay(value) {\n        if (! value) {\n            return null;\n        }\n\n        let option = this.options.find(o => o.value === value);\n\n        if (! option && this.multiple && this.selectedOption.length > 0) {\n            option = this.selectedOption[0];\n        } else if (! option && this.selectedOption && this.selectedOption.value === value) {\n            option = this.selectedOption;\n        }\n\n        return (option || { text: null }).text;\n    },\n\n    onEnter() {\n        if (! this.open) {\n            return this.openMenu();\n        }\n\n        const option = this.options[this.focusedOptionIndex];\n\n        if (option) {\n            this.selectOption(option);\n        }\n    },\n\n    selectOption(option) {\n        if (! option) {\n            return;\n        }\n\n        if (option.disabled) {\n            return;\n        }\n\n        if (this.multiple) {\n            return this.selectOptionForMultiple(option);\n        }\n\n        if (this.value === option.value && this.optional) {\n            this.value = null;\n            this.selectedOption = null;\n        } else {\n            this.value = option.value;\n            this.selectedOption = option;\n        }\n\n        this.close();\n        this.focusButton();\n    },\n\n    selectOptionForMultiple(option) {\n        if (! option) {\n            return;\n        }\n\n        if (this.value.includes(option.value)) {\n            if (this.optional || this.value.length > 1) {\n                this.value.splice(this.value.indexOf(option.value), 1);\n                this.selectedOption = [...this.value];\n            }\n\n            if (this.value.length === 0) {\n                this.selectedOption = [];\n                this.close();\n                this.focusButton();\n            }\n\n            return;\n        }\n\n        if (! this.max || Number(this.max) > this.value.length) {\n            this.value.push(option.value);\n            this.selectedOption = [...this.value];\n        }\n    },\n\n    hasSelection() {\n        if (this.multiple) {\n            return this.value.length > 0;\n        }\n\n        return Boolean(this.value);\n    },\n\n    scrollToOption(index) {\n        if (index === 0 && this.options.length > 1) {\n            index = 1;\n        }\n\n        try {\n            const child = this.$refs.listbox.children[index];\n            const offsetTop = child.offsetTop;\n            this.$refs.listbox.scrollTop = offsetTop || 0;\n\n            this.$refs.listbox.children[index].focus();\n        } catch (e) {}\n    },\n\n    toggle() {\n        if (this.open) {\n            return this.close();\n        }\n\n        this.openMenu();\n    },\n});\n","export default (array, predicate) => {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n\n    return -1;\n};\n","export const isArray = val => Array.isArray(val);\n\nexport const isUndefined = val => val === undefined;\n\nexport const isNull = val => val === null;\n\nexport const isUndefinedOrNull = val => isUndefined(val) || isNull(val);\n\n// Quick object check.\n// This is primarily used to tell Objects from primitive values\n// when we know the value is a JSON-compliant type.\n// Note: object could be a complex type like array, Date, etc.\nexport const isObject = obj => obj !== null && typeof obj === 'object';\n\n// Strict object type check.\n// Only returns true for plain JavaScript objects.\nexport const isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]';\n","export const RX_ARRAY_NOTATION = /\\[(\\d+)]/g;","const identity = x => x;\n\nexport default identity;\n","import { isArray, isNull, isObject, isUndefinedOrNull } from './inspect';\nimport { RX_ARRAY_NOTATION } from './regex';\nimport identity from './identity';\n\n/**\n * Get property defined by dot/array notation in string, returns undefined if not found.\n *\n * @param {Object} obj\n * @param {String|Array} path\n * @param {*} defaultValue\n * @return {*}\n */\nexport const getRaw = (obj, path, defaultValue = undefined) => {\n    // Handle array of path values.\n    path = isArray(path) ? path.join('.') : path;\n    \n    // If no path or object passed.\n    if (! path || ! isObject(obj)) {\n        return defaultValue;\n    }\n    \n    // Handle edge case where user has dot(s) in top-level item field key.\n    // Using `in` operator vs `hasOwnProperty` to handle obj.prototype getters.\n    if (path in obj) {\n        return obj[path];\n    }\n    \n    // Handle string array notation (numeric indices only).\n    path = String(path).replace(RX_ARRAY_NOTATION, '.$1');\n    \n    const steps = path.split('.').filter(identity);\n    \n    // Handle case where someone passes a string of only dots\n    if (steps.length === 0) {\n        return defaultValue;\n    }\n    \n    // Traverse path in object to find result.\n    // Using `in` operator vs `hasOwnProperty` to handle obj.prototype getters.\n    return steps.every(step => isObject(obj) && step in obj && ! isUndefinedOrNull((obj = obj[step])))\n        ? obj\n        : isNull(obj)\n            ? null\n            : defaultValue;\n};\n\n/**\n * Get property by dot/array notation in string.\n * \n * @param {Object} obj\n * @param {String|Array} path\n * @param {*} defaultValue (optional)\n * @return {*}\n */\nexport const get = (obj, path, defaultValue = null) => {\n    const val = getRaw(obj, path);\n    \n    return isUndefinedOrNull(val) ? defaultValue : val;\n};\n\nexport default get;\n","import { isArray, isNull, isPlainObject, isUndefined } from './inspect';\nimport get from './get';\n\nexport const normalizeOption = (option, fields = {}, key = null) => {\n    // When the option is an object, normalize it.\n    if (isPlainObject(option)) {\n        const value = get(option, fields.valueField || 'value');\n        const text = get(option, fields.textField || 'text');\n        const options = get(option, fields.optionField || 'options');\n\n        // When it has options, create an `<optgroup>` object.\n        if (! isNull(options)) {\n            return {\n                label: String(get(option, fields.labelField || 'label') || text),\n                options: normalizeOptions(options),\n            };\n        }\n\n        // Otherwise create an `<option>` object.\n        return {\n            ...option,\n\n            value: isUndefined(value) ? key || text : value,\n            text: String(isUndefined(text) ? key : text),\n            disabled: Boolean(get(option, fields.disabledField || 'disabled')),\n        };\n    }\n\n    // Otherwise create an `<option>` object from the given value.\n    return {\n        value: key || option,\n        text: String(option),\n        disabled: false,\n    };\n};\n\nexport const normalizeOptions = (options, fields = {}) => {\n    // Normalize the given options array\n    if (isArray(options)) {\n        return flattenOptions(options.map(option => normalizeOption(option, fields)));\n    }\n\n    // If not an array or object, return an empty array.\n    return [];\n};\n\nconst flattenOptions = options => {\n    let mapped = [];\n\n    options.forEach(option => {\n        // If the option has a \"label\" property, it is an `<optgroup>`, and\n        // its options need to be pushed onto the base option array.\n        if (option.hasOwnProperty('label')) {\n            mapped.push({ label: option.label });\n            mapped = mapped.concat(option.options);\n        } else {\n            mapped.push(option);\n        }\n    });\n\n    return mapped;\n};\n","import customSelect from './custom-select';\n\ndocument.addEventListener('alpine:init', () => {\n    Alpine.data('customSelect', customSelect);\n});\n"],"names":["createPopper","array","predicate","l","length","isArray","val","Array","isUndefined","undefined","isNull","isUndefinedOrNull","isObject","obj","_typeof","isPlainObject","Object","prototype","toString","call","RX_ARRAY_NOTATION","identity","x","getRaw","path","defaultValue","join","steps","String","replace","split","filter","every","step","get","normalizeOption","option","fields","key","value","valueField","text","textField","options","optionField","disabled","Boolean","disabledField","label","labelField","normalizeOptions","flattenOptions","map","mapped","forEach","hasOwnProperty","push","concat","config","focusedOptionIndex","filterable","data","open","search","wireFilter","wireListeners","selectedOption","max","selectId","optionsField","popper","this","multiple","optionDisplay","close","destroy","clear","focusButton","$nextTick","_this","$refs","button","focus","focusNextOption","nextIndex","findIndex","o","index","_this2","isOptgroup","scrollToOption","focusPreviousOption","previousIndex","findLastIndex","_this3","onHome","firstIndex","_this4","onEnd","lastIndex","_this5","isSelected","includes","initialize","$wire","$dispatch","window","Popper","TypeError","fieldNames","find","_this6","$watch","id","then","lowerCasedSearch","toLowerCase","listener","on","onMouseover","optionClasses","classes","openMenu","firstValue","_this7","container","placement","modifiers","name","offset","boundary","padding","preventScroll","onEnter","selectOption","selectOptionForMultiple","optional","splice","indexOf","Number","hasSelection","offsetTop","listbox","children","scrollTop","e","toggle","document","addEventListener","Alpine","customSelect"],"mappings":"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"}